// sample.cpp - 競技プログラミング用 C++ テンプレート（灰→茶レベル対応）
/*

このファイルは AtCoder 灰色（~199）から茶色（400+）を目指す初学者向けに、

「最低限これを知っておけば C, D 問題まで戦える」標準ライブラリ・文法・

アルゴリズム実装をワンファイルにまとめています。

必要に応じてコピー＆修正して使ってください。
*/
#include <bits/stdc++.h>
using namespace std;

//==============================================================
// 0. 基本文法 & 標準データ構造 早見表
//--------------------------------------------------------------
// ★ 配列（固定長）
int a[5] = {1, 2, 3, 4, 5};              // サイズはコンパイル時に決定

// ★ vector（可変長配列）
vector v = {1, 2, 3};               // 初期化
v.push_back(4);                          // 末尾に要素追加
int last = v.back();                     // 末尾要素取得

// ★ 2 次元配列（H×W の整数グリッドを 0 で初期化）
int H = 3, W = 4;
vector<vector> grid(H, vector(W, 0));

// ★ map / unordered_map（連想配列）
map<string, int> mp;                     // キーが昇順に並ぶ（木構造）
unordered_map<int, int> um;              // ハッシュテーブルで O(1) 期待
mp["apple"] = 3;                         // 代入
int x = mp["apple"];                   // 参照（存在しないと 0 が入る）

// ★ stack / queue / deque
stack st;   st.push(10); st.pop(); int t = st.top();
queue qu;   qu.push(1); qu.pop();  int f = qu.front();
deque dq;   dq.push_front(0); dq.push_back(1);

// ★ priority_queue（デフォルトは最大ヒープ）
priority_queue pq;              // 最大値を取り出す
priority_queue<int, vector, greater> minpq; // 最小ヒープ
pq.push(5); pq.push(1); int mx = pq.top(); pq.pop();

// ★ for ループ パターン
for (int i = 0; i < (int)v.size(); ++i) {
// インデックス付き
}
for (auto &elem : v) {
// 範囲 for（C++11〜）
}

// ★ マクロ rep（短縮表記）
#define rep(i, n) for (int i = 0; i < (int)(n); ++i)

//==============================================================
// 1. 型エイリアス・定数
//--------------------------------------------------------------
using ll  = long long;                      // 64 bit 整数
using ull = unsigned long long;             // 64 bit 符号なし整数
using pii = pair<int,int>;                  // int のペア
using pll = pair<ll,ll>;                    // ll のペア

const ll  INF  = (1LL << 60);               // 十分大きい値
const int INF32 = 1e9;                      // 32 bit 版
const ll  MOD  = 1'000'000'007LL;           // よく使う mod

//==============================================================
// 2. 便利関数
//--------------------------------------------------------------
// (1) chmin / chmax
template bool chmin(T &a, const T &b) {
if (b < a) { a = b; return true; } return false;
}

template bool chmax(T &a, const T &b) {
if (a < b) { a = b; return true; } return false;
}

// (2) modpow: a^e (mod m)
ll modpow(ll a, ll e, ll m = MOD) {
ll r = 1;
while (e) {
if (e & 1) r = (r * a) % m;
a = (a * a) % m;
e >>= 1;
}
return r;
}

//==============================================================
// 3. データ構造ライブラリ
//--------------------------------------------------------------
// 3-1. Union-Find（素集合データ構造）
struct UnionFind {
vector par, siz;
UnionFind(int n = 0): par(n,-1), siz(n,1) {}
int root(int x){ return par[x]==-1? x: par[x]=root(par[x]); }
bool unite(int a,int b){ a=root(a); b=root(b); if(a==b) return false; if(siz[a]<siz[b]) swap(a,b); par[b]=a; siz[a]+=siz[b]; return true; }
bool same(int a,int b){ return root(a)==root(b); }
int size(int x){ return siz[root(x)]; }
};

// 3-2. Binary Indexed Tree（Fenwick 木）
struct BIT {
int n; vector bit;
BIT(int n=0): n(n), bit(n+1,0) {}
void add(int i,ll val){ for(++i;i<=n;i+=i&-i) bit[i]+=val; }
ll sum(int i){ ll s=0; for(++i;i>0;i-=i&-i) s+=bit[i]; return s; }
ll sum(int l,int r){ return sum(r-1)-sum(l-1); }
};

// 3-3. セグメント木（ポイント更新・区間最小）
struct SegTree {
int n; vector dat;
SegTree(int N) {
n=1; while(n<N) n<<=1; dat.assign(2n, INF);
}
void update(int idx, ll val){ idx+=n; dat[idx]=val; while(idx>>=1) dat[idx]=min(dat[idx2],dat[idx*2+1]); }
ll query(int l,int r){ // [l,r)
ll vl=INF, vr=INF;
for(l+=n,r+=n;l<r;l>>=1,r>>=1){
if(l&1) chmin(vl,dat[l++]);
if(r&1) chmin(vr,dat[--r]);
}
return min(vl,vr);
}
};

//==============================================================
// 4. グラフアルゴリズム（BFS / ダイクストラ）
//--------------------------------------------------------------
// 4-1. BFS (01 グラフでない単純無向)
vector bfs(const vector<vector>& g, int s) {
int n = g.size();
vector dist(n, INF32);
queue q; dist[s] = 0; q.push(s);
while(!q.empty()){
int v = q.front(); q.pop();
for(int nv : g[v]) if(chmin(dist[nv], dist[v]+1)) q.push(nv);
}
return dist;
}

// 4-2. ダイクストラ (非負重み)
struct Edge { int to; ll cost; };
vector dijkstra(const vector<vector>& g, int s){
int n = g.size();
vector dist(n, INF);
using P = pair<ll,int>; priority_queue<P, vector, greater> pq;
dist[s]=0; pq.emplace(0,s);
while(!pq.empty()){
auto [d,v]=pq.top(); pq.pop(); if(d!=dist[v]) continue;
for(auto e:g) if(chmin(dist[e.to], d+e.cost)) pq.emplace(dist[e.to], e.to);
}
return dist;
}

//==============================================================
// 5. メイン関数テンプレート
//--------------------------------------------------------------
int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 入力例: N 個の整数を読み込んで合計を出力
int N; cin >> N;
vector<int> arr(N);
rep(i,N) cin >> arr[i];

ll sum = accumulate(arr.begin(), arr.end(), 0LL);
cout << sum << '\n';

return 0;

}

